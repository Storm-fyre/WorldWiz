<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Guess the Country Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
    <style>
        /* Essential for full height layouts */
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            background-color: #f8f9fa;
            display: flex; /* Make body a flex container */
            flex-direction: column; /* Stack its direct children vertically */
        }
        .container {
            flex-grow: 1; /* Allow the container to fill available vertical space */
            position: relative; /* Essential for absolute positioning of screens */
            padding: 0 15px; /* Restore Bootstrap's horizontal padding for containers */
            max-width: 100%; /* Override default max-width for better responsiveness if needed */
            margin: 0 auto; /* Center the container horizontally */
        }

        /* Styles for all screen containers to enable stacking and full height */
        .screen {
            display: none; /* Hidden by default */
            position: absolute; /* Stack screens on top of each other */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Take full height of .container */
            box-sizing: border-box; /* Include padding in height/width */
            padding: 1rem; /* Add some internal padding to all screens for content */
            text-align: center; /* Default horizontal centering for content */
        }
        #home-screen { display: block; } /* Home screen visible by default */
        
        /* General button spacing */
        .btn-space { margin: 0 10px; }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
        }

        /* Custom styles for question text to make it less imposing on mobile */
        #question-text {
            font-size: 2rem;
        }
        @media (max-width: 767.98px) {
            #question-text {
                font-size: 1.5rem;
            }
        }

        /* --- NEW HOME SCREEN LAYOUT --- */
        #home-screen.screen { /* When home-screen is active, apply flex styles */
            display: flex; /* Make home-screen a flex container */
            flex-direction: column; /* Stack its children vertically */
            align-items: center; /* Horizontally center all children within home-screen */
        }

        #home-screen h1 {
            margin-top: 0; /* Reset default h1 margin-top */
            margin-bottom: 1.5rem; /* Custom gap below title */
        }
        /* Description paragraph */
        #home-screen p.description-text {
            margin-top: 0; /* Reset default p margin-top */
            margin-bottom: 0; /* Reset default p margin-bottom; the flexible-spacer handles the large gap */
        }

        /* This spacer takes up all available vertical space, pushing content below it */
        .flexible-spacer {
            flex-grow: 1; 
            min-height: 2rem; /* Ensures a minimum gap even on very small screens */
        }

        /* Group for the Start button and contact info */
        .start-button-and-contact-group {
            display: flex;
            flex-direction: column;
            align-items: center; /* Horizontally center button and contact info */
        }
        /* Contact info specific styling for the fixed gap below the button */
        .start-button-and-contact-group .contact-info {
            margin-top: 1.5rem; /* Exactly 1.5rem gap below the button (equivalent to Bootstrap mt-4) */
            margin-bottom: 0; /* Reset default paragraph margin-bottom */
        }
        /* --- END NEW HOME SCREEN LAYOUT --- */
    </style>
</head>
<body class="container">

    <!-- Home Screen -->
    <div id="home-screen" class="screen">
        <h1>Welcome to 'I Know Your Country'!</h1>
        <p class="description-text">Think of any country, and I will guess it by asking fewer than 9 yes/no questions.</p>
        
        <div class="flexible-spacer"></div> <!-- This spacer pushes the button group towards the center -->

        <div class="start-button-and-contact-group">
            <button id="start-btn" class="btn btn-primary btn-lg">Start Game</button>
            <p class="contact-info">Creator contact: rakshann.t@gmail.com</p>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div class="card mt-4">
            <div class="card-body position-relative">
                <h2 id="question-text" class="card-title text-center mb-4"></h2>
                <div class="text-center">
                    <button id="yes-btn" class="btn btn-success btn-lg btn-space">YES</button>
                    <button id="no-btn" class="btn btn-danger btn-lg btn-space">NO</button>
                </div>
                <div class="navigation-buttons">
                    <!-- Buttons changed to btn-sm for smaller size -->
                    <button id="game-back-btn" class="btn btn-secondary btn-sm">Back</button>
                    <button id="game-restart-btn" class="btn btn-info btn-sm">Restart</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="screen">
        <h1>Your country is: <span id="country-name" class="text-primary"></span></h1>
        <div class="navigation-buttons justify-content-center">
            <!-- Buttons changed to btn-sm for smaller size -->
            <button id="result-back-btn" class="btn btn-secondary btn-sm mx-2">Back</button>
            <button id="result-restart-btn" class="btn btn-primary btn-sm mx-2">Restart</button>
        </div>
    </div>
    
    <!-- Loading/Error Indicator -->
    <div id="loading-screen" class="screen">
        <h2 id="loading-text">Loading Game...</h2>
    </div>


    <script>
        // --- DOM Elements ---
        const screens = { home: document.getElementById('home-screen'), game: document.getElementById('game-screen'), result: document.getElementById('result-screen'), loading: document.getElementById('loading-screen') };
        const buttons = { start: document.getElementById('start-btn'), yes: document.getElementById('yes-btn'), no: document.getElementById('no-btn'), gameBack: document.getElementById('game-back-btn'), resultBack: document.getElementById('result-back-btn'), gameRestart: document.getElementById('game-restart-btn'), resultRestart: document.getElementById('result-restart-btn') };
        const elements = { questionText: document.getElementById('question-text'), countryName: document.getElementById('country-name'), loadingText: document.getElementById('loading-text') };

        // --- Game State (Modified) ---
        let allRoots = {}; // Object to hold all parsed root nodes (asia, americasEurope, africa, misc)
        let currentTreeRoot = null; // The root node of the *current decision tree* being traversed (e.g., allRoots.asia)
        let currentNode = null; // The current node *within* currentTreeRoot's tree
        let rootAttemptSequence = []; // Array defining the specific order of root nodes to attempt for the current game
        let currentRootAttemptIndex = 0; // Index into rootAttemptSequence
        let history = []; // To track nodes for the 'Back' button

        // --- Core Logic ---

        function parseTree(treeText) {
            const lines = treeText.trim().split('\n');
            if (lines.length === 0) return null;
            const getDepth = (line) => (line.length - line.trimStart().length) / 4;
            const root = { text: lines[0].trim(), yes: null, no: null };
            const parentStack = [ { node: root, depth: 0 } ]; 

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                const depth = getDepth(line);
                const text = line.trim();

                while (parentStack.length > 0 && parentStack[parentStack.length - 1].depth >= depth) {
                    parentStack.pop();
                }

                const parent = parentStack[parentStack.length - 1].node;
                let newNode = null;

                if (text.startsWith("YES:")) {
                    const content = text.substring(4).trim();
                    if (content) {
                        parent.yes = { text: content, yes: null, no: null };
                    } else {
                        const nextLine = lines[i + 1];
                        const nextText = nextLine.trim();
                        newNode = { text: nextText, yes: null, no: null };
                        parent.yes = newNode;
                        i++;
                    }
                } else if (text.startsWith("NO:")) {
                    const content = text.substring(3).trim();
                    if (content) {
                        parent.no = { text: content, yes: null, no: null };
                    } else {
                        const nextLine = lines[i + 1];
                        const nextText = nextLine.trim();
                        newNode = { text: nextText, yes: null, no: null };
                        parent.no = newNode;
                        i++;
                    }
                }

                if (newNode) {
                    parentStack.push({ node: newNode, depth: getDepth(lines[i]) });
                }
            }
            return root;
        }
        
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.style.display = 'none');
            if (screens[screenName]) screens[screenName].style.display = 'flex'; // Changed to flex for home-screen layout
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function startGame() {
            history = []; // Clear history for a new game

            // Determine the sequence of roots to attempt based on user's request
            let initialTwoRoots = [allRoots.asia, allRoots.americasEurope];
            shuffleArray(initialTwoRoots); // Randomly order Asia and Americas/Europe

            rootAttemptSequence = [
                initialTwoRoots[0], // First randomly chosen of the initial two
                initialTwoRoots[1], // The other of the initial two
                allRoots.africa,    // Then Africa
                allRoots.misc       // Finally, the miscellaneous tree as the last resort
            ];
            
            currentRootAttemptIndex = 0;
            currentTreeRoot = rootAttemptSequence[currentRootAttemptIndex]; // Set the first root to try
            currentNode = currentTreeRoot; // Start traversal from this root's question
            
            displayCurrentNode();
        }

        function displayCurrentNode() {
            if (!currentNode) {
                showResult("Something went wrong! Let's restart.");
                return;
            }
            if (!currentNode.yes && !currentNode.no) { // It's a leaf node (a country guess)
                showResult(currentNode.text);
            } else { // It's a question node
                elements.questionText.textContent = currentNode.text;
                showScreen('game');
            }
        }
        
        /**
         * Handles the user's answer, with modified logic for switching between root trees.
         */
        function handleAnswer(answer) {
            if (!currentNode) return;
            
            history.push(currentNode); // Always push the current node before moving to the next question

            // Check if the current question being answered is the root question of the *current tree we are exploring*
            let isAnsweringCurrentTreeRootQuestion = (currentNode === currentTreeRoot);

            let nextNode = (answer === 'YES') ? currentNode.yes : currentNode.no;
            
            if (nextNode) {
                currentNode = nextNode; // Move deeper into the current tree
            } else { // No direct path forward from this node (either a dead end or a specific 'NO' to a root)
                if (answer === 'NO') {
                    if (isAnsweringCurrentTreeRootQuestion) { // If player said NO to the *root question* of the current tree
                        currentRootAttemptIndex++; // Try the next tree in the sequence
                        if (currentRootAttemptIndex < rootAttemptSequence.length) {
                            currentTreeRoot = rootAttemptSequence[currentRootAttemptIndex]; // Set the new current tree root
                            currentNode = currentTreeRoot; // Start from the root question of this new tree
                        } else {
                            // This case should ideally not be hit if allRoots.misc is included as the last item
                            // but as a safeguard, if somehow the sequence exhausts.
                            showResult("I give up! I couldn't guess your country.");
                            return;
                        }
                    } else { // Player said NO to a non-root question, and that specific branch path is exhausted
                        showResult(`I'm lost! The path from "${currentNode.text}" seems incomplete.`);
                        return;
                    }
                } else { // Player said YES to a question, but the YES path is null (tree is malformed)
                     showResult(`I thought it was ${currentNode.text}, but I seem to be wrong.`);
                     return;
                }
            }
            displayCurrentNode(); // Display the new question or the result
        }

        function goBack() {
            if (history.length === 0) {
                restartGame(); // If no history, go back to home screen
                return;
            }
            currentNode = history.pop(); // Go back to the previous question
            
            // Re-evaluate currentTreeRoot and currentRootAttemptIndex based on the returned currentNode
            for (let i = 0; i < rootAttemptSequence.length; i++) {
                // If the node we are going back to is a root of one of our main trees, set it as currentTreeRoot
                if (currentNode === rootAttemptSequence[i]) {
                    currentTreeRoot = rootAttemptSequence[i];
                    currentRootAttemptIndex = i;
                    break;
                }
            }
            displayCurrentNode();
        }

        function restartGame() {
            history = [];
            currentTreeRoot = null;
            currentNode = null;
            rootAttemptSequence = [];
            currentRootAttemptIndex = 0;
            showScreen('home');
        }

        function showResult(country) {
            elements.countryName.textContent = country;
            showScreen('result');
        }
        
        buttons.start.addEventListener('click', startGame);
        buttons.yes.addEventListener('click', () => handleAnswer('YES'));
        buttons.no.addEventListener('click', () => handleAnswer('NO'));
        buttons.gameBack.addEventListener('click', goBack);
        buttons.resultBack.addEventListener('click', goBack);
        buttons.gameRestart.addEventListener('click', restartGame);
        buttons.resultRestart.addEventListener('click', restartGame);

        /**
         * Initializes the game by parsing all decision trees.
         */
        async function initializeGame() {
            showScreen('loading');
            try {
                const response = await fetch('decision.txt');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();
                const treeTexts = text.split('---TREE---').filter(t => t.trim());
                if (treeTexts.length < 4) throw new Error("The data file must contain at least 4 trees.");

                // Parse and assign to specific root variables
                allRoots.asia = parseTree(treeTexts[0]);
                allRoots.americasEurope = parseTree(treeTexts[1]);
                allRoots.africa = parseTree(treeTexts[2]);
                allRoots.misc = parseTree(treeTexts[3]); // The last one is the fallback/monarchy tree

                if (!allRoots.asia || !allRoots.americasEurope || !allRoots.africa || !allRoots.misc) {
                     throw new Error("Failed to parse all decision trees correctly. Check decision.txt for structure.");
                }
                
                showScreen('home');
            } catch (error) {
                console.error('Failed to load or parse tree data:', error);
                elements.loadingText.textContent = `Error: ${error.message}`;
                elements.loadingText.classList.add('text-danger');
            }
        }

        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>
