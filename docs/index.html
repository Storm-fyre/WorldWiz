<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Guess the Country Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .screen { display: none; }
        #home-screen { display: block; }
        .btn-space { margin: 0 10px; }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
        }
        /* Custom styles for question text to make it less imposing */
        #question-text {
            font-size: 2rem; /* A bit smaller than default h2 for larger screens */
        }
        @media (max-width: 767.98px) { /* Applies to screens smaller than 768px (common mobile breakpoint) */
            #question-text {
                font-size: 1.5rem; /* Even smaller for mobile devices */
            }
        }

        /* Custom margin for the large gap */
        .mb-extra-large {
            margin-bottom: 10rem !important; /* Approximately 10 times the default mt-3/mt-4 */
        }
    </style>
</head>
<body class="container mt-5">

    <!-- Home Screen -->
    <div id="home-screen" class="screen text-center">
        <h1>Welcome to 'I Know Your Country'!</h1>
        <!-- Increased gap below this paragraph -->
        <p class="mt-3 mb-extra-large">Think of any country, and I will guess it by asking fewer than 9 yes/no questions.</p>
        <div class="mt-4">
            <button id="start-btn" class="btn btn-primary btn-lg">Start Game</button>
        </div>
        <!-- Creator contact added below the start button -->
        <p class="mt-4">Creator contact: rakshann.t@gmail.com</p>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div class="card mt-4">
            <div class="card-body position-relative">
                <h2 id="question-text" class="card-title text-center mb-4"></h2>
                <div class="text-center">
                    <button id="yes-btn" class="btn btn-success btn-lg btn-space">YES</button>
                    <button id="no-btn" class="btn btn-danger btn-lg btn-space">NO</button>
                </div>
                <div class="navigation-buttons">
                    <!-- Buttons changed to btn-sm for smaller size -->
                    <button id="game-back-btn" class="btn btn-secondary btn-sm">Back</button>
                    <button id="game-restart-btn" class="btn btn-info btn-sm">Restart</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="screen text-center">
        <h1>Your country is: <span id="country-name" class="text-primary"></span></h1>
        <div class="navigation-buttons justify-content-center">
            <!-- Buttons changed to btn-sm for smaller size -->
            <button id="result-back-btn" class="btn btn-secondary btn-sm mx-2">Back</button>
            <button id="result-restart-btn" class="btn btn-primary btn-sm mx-2">Restart</button>
        </div>
    </div>
    
    <!-- Loading/Error Indicator -->
    <div id="loading-screen" class="screen text-center">
        <h2 id="loading-text">Loading Game...</h2>
    </div>


    <script>
        // --- DOM Elements ---
        const screens = { home: document.getElementById('home-screen'), game: document.getElementById('game-screen'), result: document.getElementById('result-screen'), loading: document.getElementById('loading-screen') };
        const buttons = { start: document.getElementById('start-btn'), yes: document.getElementById('yes-btn'), no: document.getElementById('no-btn'), gameBack: document.getElementById('game-back-btn'), resultBack: document.getElementById('result-back-btn'), gameRestart: document.getElementById('game-restart-btn'), resultRestart: document.getElementById('result-restart-btn') };
        const elements = { questionText: document.getElementById('question-text'), countryName: document.getElementById('country-name'), loadingText: document.getElementById('loading-text') };

        // --- Game State (Modified) ---
        let allRoots = {}; // Object to hold all parsed root nodes (asia, americasEurope, africa, misc)
        let currentTreeRoot = null; // The root node of the *current decision tree* being traversed (e.g., allRoots.asia)
        let currentNode = null; // The current node *within* currentTreeRoot's tree
        let rootAttemptSequence = []; // Array defining the specific order of root nodes to attempt for the current game
        let currentRootAttemptIndex = 0; // Index into rootAttemptSequence
        let history = []; // To track nodes for the 'Back' button

        // --- Core Logic ---

        function parseTree(treeText) {
            const lines = treeText.trim().split('\n');
            if (lines.length === 0) return null;
            const getDepth = (line) => (line.length - line.trimStart().length) / 4;
            const root = { text: lines[0].trim(), yes: null, no: null };
            const parentStack = [ { node: root, depth: 0 } ]; 

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                const depth = getDepth(line);
                const text = line.trim();

                while (parentStack.length > 0 && parentStack[parentStack.length - 1].depth >= depth) {
                    parentStack.pop();
                }

                const parent = parentStack[parentStack.length - 1].node;
                let newNode = null;

                if (text.startsWith("YES:")) {
                    const content = text.substring(4).trim();
                    if (content) {
                        parent.yes = { text: content, yes: null, no: null };
                    } else {
                        const nextLine = lines[i + 1];
                        const nextText = nextLine.trim();
                        newNode = { text: nextText, yes: null, no: null };
                        parent.yes = newNode;
                        i++;
                    }
                } else if (text.startsWith("NO:")) {
                    const content = text.substring(3).trim();
                    if (content) {
                        parent.no = { text: content, yes: null, no: null };
                    } else {
                        const nextLine = lines[i + 1];
                        const nextText = nextLine.trim();
                        newNode = { text: nextText, yes: null, no: null };
                        parent.no = newNode;
                        i++;
                    }
                }

                if (newNode) {
                    parentStack.push({ node: newNode, depth: getDepth(lines[i]) });
                }
            }
            return root;
        }
        
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.style.display = 'none');
            if (screens[screenName]) screens[screenName].style.display = 'block';
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function startGame() {
            history = []; // Clear history for a new game

            // Determine the sequence of roots to attempt based on user's request
            let initialTwoRoots = [allRoots.asia, allRoots.americasEurope];
            shuffleArray(initialTwoRoots); // Randomly order Asia and Americas/Europe

            rootAttemptSequence = [
                initialTwoRoots[0], // First randomly chosen of the initial two
                initialTwoRoots[1], // The other of the initial two
                allRoots.africa,    // Then Africa
                allRoots.misc       // Finally, the miscellaneous tree as the last resort
            ];
            
            currentRootAttemptIndex = 0;
            currentTreeRoot = rootAttemptSequence[currentRootAttemptIndex]; // Set the first root to try
            currentNode = currentTreeRoot; // Start traversal from this root's question
            
            displayCurrentNode();
        }

        function displayCurrentNode() {
            if (!currentNode) {
                showResult("Something went wrong! Let's restart.");
                return;
            }
            if (!currentNode.yes && !currentNode.no) { // It's a leaf node (a country guess)
                showResult(currentNode.text);
            } else { // It's a question node
                elements.questionText.textContent = currentNode.text;
                showScreen('game');
            }
        }
        
        /**
         * Handles the user's answer, with modified logic for switching between root trees.
         */
        function handleAnswer(answer) {
            if (!currentNode) return;
            
            history.push(currentNode); // Always push the current node before moving to the next question

            // Check if the current question being answered is the root question of the *current tree we are exploring*
            let isAnsweringCurrentTreeRootQuestion = (currentNode === currentTreeRoot);

            let nextNode = (answer === 'YES') ? currentNode.yes : currentNode.no;
            
            if (nextNode) {
                currentNode = nextNode; // Move deeper into the current tree
            } else { // No direct path forward from this node (either a dead end or a specific 'NO' to a root)
                if (answer === 'NO') {
                    if (isAnsweringCurrentTreeRootQuestion) { // If player said NO to the *root question* of the current tree
                        currentRootAttemptIndex++; // Try the next tree in the sequence
                        if (currentRootAttemptIndex < rootAttemptSequence.length) {
                            currentTreeRoot = rootAttemptSequence[currentRootAttemptIndex]; // Set the new current tree root
                            currentNode = currentTreeRoot; // Start from the root question of this new tree
                        } else {
                            // This case should ideally not be hit if allRoots.misc is included as the last item
                            // but as a safeguard, if somehow the sequence exhausts.
                            showResult("I give up! I couldn't guess your country.");
                            return;
                        }
                    } else { // Player said NO to a non-root question, and that specific branch path is exhausted
                        showResult(`I'm lost! The path from "${currentNode.text}" seems incomplete.`);
                        return;
                    }
                } else { // Player said YES to a question, but the YES path is null (tree is malformed)
                     showResult(`I thought it was ${currentNode.text}, but I seem to be wrong.`);
                     return;
                }
            }
            displayCurrentNode(); // Display the new question or the result
        }

        function goBack() {
            if (history.length === 0) {
                restartGame(); // If no history, go back to home screen
                return;
            }
            currentNode = history.pop(); // Go back to the previous question
            
            // Re-evaluate currentTreeRoot and currentRootAttemptIndex based on the returned currentNode
            for (let i = 0; i < rootAttemptSequence.length; i++) {
                if (currentNode === rootAttemptSequence[i]) {
                    currentTreeRoot = rootAttemptSequence[i];
                    currentRootAttemptIndex = i;
                    break;
                }
            }

            displayCurrentNode();
        }

        function restartGame() {
            history = [];
            currentTreeRoot = null;
            currentNode = null;
            rootAttemptSequence = [];
            currentRootAttemptIndex = 0;
            showScreen('home');
        }

        function showResult(country) {
            elements.countryName.textContent = country;
            showScreen('result');
        }
        
        buttons.start.addEventListener('click', startGame);
        buttons.yes.addEventListener('click', () => handleAnswer('YES'));
        buttons.no.addEventListener('click', () => handleAnswer('NO'));
        buttons.gameBack.addEventListener('click', goBack);
        buttons.resultBack.addEventListener('click', goBack);
        buttons.gameRestart.addEventListener('click', restartGame);
        buttons.resultRestart.addEventListener('click', restartGame);

        /**
         * Initializes the game by parsing all decision trees.
         */
        async function initializeGame() {
            showScreen('loading');
            try {
                const response = await fetch('decision.txt');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();
                const treeTexts = text.split('---TREE---').filter(t => t.trim());
                if (treeTexts.length < 4) throw new Error("The data file must contain at least 4 trees.");

                // Parse and assign to specific root variables
                allRoots.asia = parseTree(treeTexts[0]);
                allRoots.americasEurope = parseTree(treeTexts[1]);
                allRoots.africa = parseTree(treeTexts[2]);
                allRoots.misc = parseTree(treeTexts[3]); // The last one is the fallback/monarchy tree

                if (!allRoots.asia || !allRoots.americasEurope || !allRoots.africa || !allRoots.misc) {
                     throw new Error("Failed to parse all decision trees correctly. Check decision.txt for structure.");
                }
                
                showScreen('home');
            } catch (error) {
                console.error('Failed to load or parse tree data:', error);
                elements.loadingText.textContent = `Error: ${error.message}`;
                elements.loadingText.classList.add('text-danger');
            }
        }

        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>


